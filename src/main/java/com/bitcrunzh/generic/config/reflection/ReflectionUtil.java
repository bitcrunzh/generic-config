package com.bitcrunzh.generic.config.reflection;

import com.bitcrunzh.generic.config.description.java.ClassDescriptionCache;
import com.bitcrunzh.generic.config.description.java.PropertyDescription;
import com.bitcrunzh.generic.config.reflection.annotation.property.IgnoredProperty;
import com.bitcrunzh.generic.config.reflection.annotation.util.ConstructParamFieldMapping;
import com.bitcrunzh.generic.config.reflection.annotation.util.FieldGetter;
import com.bitcrunzh.generic.config.reflection.annotation.util.FieldSetter;
import com.bitcrunzh.generic.config.value.java.NormalizedObject;
import com.bitcrunzh.generic.config.value.java.NormalizedProperty;

import java.lang.reflect.*;
import java.util.*;
import java.util.function.Function;

public class ReflectionUtil {

    private ReflectionUtil() {
    }

    public static boolean isAbstractClassOrInterface(Class<?> type) {
        return Modifier.isInterface(type.getModifiers()) || Modifier.isAbstract(type.getModifiers());
    }

    public static <T> Method findSetterMethod(Class<T> parentType, Field fieldToFindSetterFor) {
        String nameToMatch = String.format("set%s", fieldToFindSetterFor.getName());
        for (Method method : parentType.getMethods()) {
            Method matchingMethod = null;
            if (method.getName().equalsIgnoreCase(nameToMatch)) {
                matchingMethod = method;
            }
            FieldSetter setterAnnotation = method.getAnnotation(FieldSetter.class);
            if (matchingMethod == null && setterAnnotation != null && setterAnnotation.fieldName().equals(fieldToFindSetterFor.getName())) {
                matchingMethod = method;
            }
            Class<?>[] setterParameters = method.getParameterTypes();
            if (!isUsableSetterMethod(fieldToFindSetterFor, method, setterParameters)) continue;
            if (matchingMethod != null) {
                return matchingMethod;
            }
        }
        return null;
    }

    private static boolean isUsableSetterMethod(Field fieldToFindSetterFor, Method method, Class<?>[] setterParameters) {
        if (setterParameters.length != 1 || !setterParameters[0].isAssignableFrom(fieldToFindSetterFor.getType())) {
            return false; //Setter method should only take the value to set.
        }
        //Setter should be public for the framework to use it. Compiler bridge methods should not be used as they will have the wrong type to set even though name matches.
        return Modifier.isPublic(method.getModifiers()) && !method.isBridge();
    }

    public static <T> Method findGetterMethod(Class<T> parentType, Field fieldToFindGetterFor) {
        List<String> namesToTryMatch = new ArrayList<>();
        if (fieldToFindGetterFor.getType() == Boolean.class || fieldToFindGetterFor.getType() == boolean.class) {
            if (fieldToFindGetterFor.getName().startsWith("is")) {
                namesToTryMatch.add(fieldToFindGetterFor.getName());
            }
            namesToTryMatch.add(String.format("is%s", fieldToFindGetterFor.getName()));
        }
        namesToTryMatch.add(String.format("get%s", fieldToFindGetterFor.getName()));

        for (Method method : parentType.getMethods()) {
            Method methodFound = findGetterMethodFromGetterAnnotation(parentType, fieldToFindGetterFor, method);
            if (methodFound == null) {
                methodFound = findGetterMethodFromFieldName(fieldToFindGetterFor, method, namesToTryMatch);
            }
            if (methodFound != null) return methodFound;
        }
        throw new IllegalArgumentException(String.format("Unable to find getter method for '%s.%s:%s'", parentType.getSimpleName(), fieldToFindGetterFor.getName(), fieldToFindGetterFor.getType().getSimpleName()));
    }

    private static Method findGetterMethodFromFieldName(Field fieldToFindGetterFor, Method method, List<String> namesToTryMatch) {
        for (String nameToMatch : namesToTryMatch) {
            if (!Modifier.isPublic(method.getModifiers()) || method.isBridge()) {
                continue;
            }
            if (method.getName().equalsIgnoreCase(nameToMatch) && (method.getReturnType().isPrimitive() || fieldToFindGetterFor.getType().isAssignableFrom(method.getReturnType()))) {
                return method;
            }
        }
        return null;
    }

    private static <T> Method findGetterMethodFromGetterAnnotation(Class<T> parentType, Field fieldToFindGetterFor, Method method) {
        FieldGetter getterAnnotation = method.getAnnotation(FieldGetter.class);
        if (getterAnnotation != null && getterAnnotation.fieldName().equals(fieldToFindGetterFor.getName())) {
            if (method.isBridge()) { //Method generated by the Java Compiler, using Object for generic types, including those declared in interfaces, even though implemented as specific type in a class.
                return null;
            }
            if (method.getReturnType().isPrimitive() || fieldToFindGetterFor.getType().isAssignableFrom(method.getReturnType())) {
                return method;
            } else {
                throw new IllegalArgumentException(String.format("Method '%s.%s:%s', is annotated as a getter for field '%s:%s' but types does not match.", parentType.getSimpleName(), method.getName(), method.getReturnType().getSimpleName(), fieldToFindGetterFor.getName(), fieldToFindGetterFor.getType().getSimpleName()));
            }
        }
        return null;
    }

    public static <T> Function<NormalizedObject<T>, T> createConstructorFunction(final Class<T> type, List<PropertyDescription<T, ?>> propertyDescriptions, ClassDescriptionCache classDescriptionCache) {
        Map<String, PropertyDescription<T, ?>> propertyMap = new HashMap<>();
        List<PropertyDescription<T, ?>> propertyDescriptionsToMatch = new ArrayList<>(propertyDescriptions);
        for (PropertyDescription<T, ?> property : propertyDescriptionsToMatch) {
            propertyMap.put(property.getPropertyName(), property);
        }

        List<String> notMatchingConstructors = new ArrayList<>();
        for (final Constructor<?> constructor : type.getDeclaredConstructors()) {
            @SuppressWarnings("unchecked") Function<NormalizedObject<T>, T> typedConstructor = createConstructorFunctionIfMatchesProperties(type, propertyDescriptionsToMatch, (Constructor<T>) constructor, notMatchingConstructors, propertyMap, classDescriptionCache);
            if (typedConstructor != null) return typedConstructor;
        }
        StringBuilder stringBuilder = new StringBuilder();
        int i = 1;
        for (String notMatchingConstructor : notMatchingConstructors) {
            stringBuilder.append(System.lineSeparator()).append(i++).append(") ").append(notMatchingConstructor);
        }
        throw new IllegalStateException(String.format("No suitable public constructor found for type %s. The following constructors was found but not matching:%s", type.getSimpleName(), stringBuilder));
    }

    private static <T> Function<NormalizedObject<T>, T> createConstructorFunctionIfMatchesProperties(Class<T> type, List<PropertyDescription<T, ?>> propertyDescriptions, Constructor<T> constructor, List<String> notMatchingConstructors, Map<String, PropertyDescription<T, ?>> propertyMap, ClassDescriptionCache classDescriptionCache) {
        if (!type.isAssignableFrom(constructor.getDeclaringClass())) {
            return null;
        }
        if (!Modifier.isPublic(constructor.getModifiers())) {
            notMatchingConstructors.add(String.format("%s(%s) - Not public access modifier.", type.getSimpleName(), createConstructorParameterString(constructor.getParameterTypes(), null)));
            return null;
        }
        final Constructor<T> typedConstructor = constructor;

        Set<String> unassignedParameters = new HashSet<>();
        Map<String, PropertyDescription<T, ?>> propertyDescriptionMap = new HashMap<>();
        for (PropertyDescription<T, ?> propertyDescription : propertyDescriptions) {
            unassignedParameters.add(propertyDescription.getPropertyName());
            propertyDescriptionMap.put(propertyDescription.getPropertyName(), propertyDescription);
        }

        if (propertyDescriptions.isEmpty()) {
            if (isNoArgConstructor(typedConstructor)) {
                return createEmptyConstructorFunction(typedConstructor);
            } else {
                notMatchingConstructors.add(String.format("%s(%s) - Constructor has parameters, but there is no annotated properties to set.", type.getSimpleName(), createConstructorParameterString(constructor.getParameterTypes(), null)));
                return null;
            }
        }

        Class<?>[] parameterTypes = typedConstructor.getParameterTypes();
        List<ConstructorParameter> mappedParametersConAnno = mapConstructorParametersToFields(type, typedConstructor.getAnnotation(ConstructParamFieldMapping.class), parameterTypes, propertyMap);

        final Map<String, ConstructorParameter> fieldNameConstructorParameters = createFieldNameToConstructorParameterMap(mappedParametersConAnno);
        if (parameterTypes.length > 0 && fieldNameConstructorParameters.size() != parameterTypes.length) {
            notMatchingConstructors.add(String.format("%s(%s) - Constructor has parameters, but they are not all mapped to fields. Please use  @%s constructor annotation to map constructor parameters to field names.", type.getSimpleName(), createConstructorParameterString(constructor.getParameterTypes(), null), ConstructParamFieldMapping.class.getSimpleName()));
            return null;
        }

        final Map<Integer, String> constructorParamIndexFieldName = createConstructorParameterIndexAndUpdateUnassignedParameters(fieldNameConstructorParameters, unassignedParameters);
        final List<ConstructionSetter> propertySetters = getConstructionSettersAndUpdateUnassignedParameters(type, unassignedParameters);

        if (!unassignedParameters.isEmpty()) {
            notMatchingConstructors.add(String.format("%s(%s)%s - No setter methods found for fields: %s.", typedConstructor.getDeclaringClass().getSimpleName(), createConstructorParameterString(typedConstructor.getParameterTypes(), constructorParamIndexFieldName), createSetterFoundString(propertySetters), createSetterString(unassignedParameters)));
            return null;
        }

        return normalizedObject -> {
            Object[] constructorParameters = new Object[constructorParamIndexFieldName.size()];
            for (int parameterIndex = 0; parameterIndex < constructorParameters.length; parameterIndex++) {
                String fieldName = constructorParamIndexFieldName.get(parameterIndex);
                constructorParameters[parameterIndex] = normalizedObject.getProperty(fieldName);
            }
            try {
                T object = typedConstructor.newInstance(constructorParameters);
                for (ConstructionSetter propertySetter : propertySetters) {
                    NormalizedProperty<Object> normalizedValue = normalizedObject.getProperty(propertySetter.fieldName);
                    PropertyDescription<T, ?> propertyDescription = propertyDescriptionMap.get(propertySetter.fieldName);
                    @SuppressWarnings("unchecked") Object value = getValue(normalizedValue, (PropertyDescription<T, Object>) propertyDescription, classDescriptionCache);
                    propertySetter.setterMethod.invoke(object, value);
                }
                return object;
            } catch (InstantiationException e) {
                throw new IllegalStateException("Failed to instantiate object.", e);
            } catch (IllegalAccessException e) {
                throw new IllegalStateException("Failed to instantiate object. Constructor must be public.", e);
            } catch (InvocationTargetException e) {
                throw new IllegalStateException("Failed to instantiate object. Wrong invocation target.", e);
            }
        };
    }

    private static String createSetterFoundString(List<ConstructionSetter> propertySetters) {
        if (propertySetters.isEmpty()) {
            return "";
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(", Setter methods found for fields ");
        for (ConstructionSetter setter : propertySetters) {
            stringBuilder.append("'").append(setter.fieldName).append(" -> ").append(setter.setterMethod.getName()).append("', ");
        }
        return stringBuilder.substring(0, stringBuilder.length() - 2);
    }

    private static String createSetterString(Set<String> unmatchedFields) {
        StringBuilder stringBuilder = new StringBuilder();
        for (String field : unmatchedFields) {
            stringBuilder.append("'").append(field).append("', ");
        }
        return stringBuilder.substring(0, stringBuilder.length() - 2);
    }

    private static <T, V> Object getValue(NormalizedProperty<V> normalizedValue, PropertyDescription<T, V> propertyDescription, ClassDescriptionCache classDescriptionCache) {
        return propertyDescription.createProperty(normalizedValue);
    }

    private static <T> List<ConstructionSetter> getConstructionSettersAndUpdateUnassignedParameters(Class<T> type, Set<String> unassignedParameters) {
        final List<ConstructionSetter> propertySetters = new ArrayList<>();
        List<TypeAndFields> parentTypeFields = createInheritedTypesAndFields(type);
        for (TypeAndFields typeAndFields : parentTypeFields) {
            for (Field nonConstProperty : typeAndFields.fields) {
                if (!unassignedParameters.contains(nonConstProperty.getName()) || isIgnoredField(nonConstProperty) || Modifier.isFinal(nonConstProperty.getModifiers())) {
                    continue;
                }
                Method setterMethod = findSetterMethod(typeAndFields.type, nonConstProperty);
                if (setterMethod == null) {
                    throw new IllegalArgumentException(String.format("Could not find setter method for '%s.%s:%s'", typeAndFields.type.getSimpleName(), nonConstProperty.getName(), nonConstProperty.getType().getSimpleName()));
                }
                propertySetters.add(new ConstructionSetter(nonConstProperty.getName(), setterMethod));
                unassignedParameters.remove(nonConstProperty.getName());
            }
        }
        return propertySetters;
    }

    public static boolean isIgnoredField(Field nonConstProperty) {
        return nonConstProperty.getAnnotation(IgnoredProperty.class) != null;
    }

    private static <T> List<TypeAndFields> createInheritedTypesAndFields(Class<T> type) {
        List<TypeAndFields> typeAndFields = new ArrayList<>();
        typeAndFields.add(new TypeAndFields(type, Arrays.asList(type.getDeclaredFields())));
        Class<?> superClass = type.getSuperclass();
        while (superClass != null) {
            typeAndFields.add(new TypeAndFields(superClass, Arrays.asList(superClass.getDeclaredFields())));
            superClass = superClass.getSuperclass();
        }
        return typeAndFields;
    }

    private static Map<Integer, String> createConstructorParameterIndexAndUpdateUnassignedParameters(Map<String, ConstructorParameter> fieldNameConstructorParameters, Set<String> unassignedParameters) {
        final Map<Integer, String> constructorParameterIndexFieldName = new HashMap<>();
        for (ConstructorParameter constParam : fieldNameConstructorParameters.values()) {
            constructorParameterIndexFieldName.put(constParam.parameterIndex, constParam.fieldName);
            unassignedParameters.remove(constParam.fieldName);
        }
        return constructorParameterIndexFieldName;
    }


    private static <T> Function<NormalizedObject<T>, T> createEmptyConstructorFunction(Constructor<T> typedConstructor) {
        return normalizedObject -> {
            try {
                return typedConstructor.newInstance();
            } catch (InstantiationException e) {
                throw new IllegalStateException("Failed to instantiate object.", e);
            } catch (IllegalAccessException e) {
                throw new IllegalStateException("Failed to instantiate object. Constructor must be public.", e);
            } catch (InvocationTargetException e) {
                throw new IllegalStateException("Failed to instantiate object. Wrong invocation target.", e);
            }
        };
    }

    private static <T> List<ConstructorParameter> mapConstructorParametersToFields(Class<T> type, ConstructParamFieldMapping parameterFieldMappings, Class<?>[] parameterTypes, Map<String, PropertyDescription<T, ?>> propertyMap) {
        if (parameterFieldMappings == null) {
            return Collections.emptyList();
        }
        if (parameterFieldMappings.paramFieldNames().length != parameterTypes.length) {
            throw new IllegalArgumentException(String.format("@ConstructorParameterFields annotation for type '%s' must have the same number of fieldNames as there is constructor parameter arguments. Was '%d' (%s), expected '%d'.", type.getSimpleName(), parameterFieldMappings.paramFieldNames().length, Arrays.asList(parameterFieldMappings.paramFieldNames()), parameterTypes.length));
        }
        List<ConstructorParameter> mappedConstructorParameters = new ArrayList<>();
        for (int idx = 0; idx < parameterFieldMappings.paramFieldNames().length; idx++) {
            Class<?> parameterType = parameterTypes[idx];
            String fieldName = parameterFieldMappings.paramFieldNames()[idx];
            assertConstructorParameterFieldMappingValid(type, propertyMap, ConstructParamFieldMapping.class, fieldName, parameterType);
            mappedConstructorParameters.add(new ConstructorParameter(idx, fieldName));
        }
        return mappedConstructorParameters;
    }

    private static <T> void assertConstructorParameterFieldMappingValid(Class<T> type, Map<String, PropertyDescription<T, ?>> propertyMap, Class<?> annotationClass, String fieldName, Class<?> parameterType) {
        PropertyDescription<T, ?> propertyMatch = propertyMap.get(fieldName);
        if (propertyMatch == null) {
            throw new IllegalArgumentException(String.format("Constructor parameter @%s annotation for class '%s' references field '%s', but it does not exist or is not annotated.", annotationClass.getSimpleName(), type.getSimpleName(), fieldName));
        }
        if (!propertyMatch.getType().isAssignableFrom(parameterType)) {
            throw new IllegalArgumentException(String.format("Constructor parameter @%s annotation for class '%s' references field '%s', but the field '%s' type '%s' is not assignable from the constructor parameter type '%s'.", annotationClass.getSimpleName(), type.getSimpleName(), fieldName, propertyMatch.getPropertyName(), propertyMatch.getType().getSimpleName(), parameterType.getSimpleName()));
        }
        if((parameterType.isPrimitive() && !propertyMatch.getType().isPrimitive()) || (!parameterType.isPrimitive() && propertyMatch.getType().isPrimitive())) {
            throw new IllegalArgumentException(String.format("Constructor parameter @%s annotation for class '%s' references field '%s', but the field '%s' type '%s' and parameter type '%s' is not both primitive or object type.", annotationClass.getSimpleName(), type.getSimpleName(), fieldName, propertyMatch.getPropertyName(), propertyMatch.getType().getSimpleName(), parameterType.getSimpleName()));
        }
    }

    private static Map<String, ConstructorParameter> createFieldNameToConstructorParameterMap(List<ConstructorParameter> mappedParametersConAnno) {
        Map<String, ConstructorParameter> fieldNameConstructorParameters = new HashMap<>();
        for (ConstructorParameter constructorParameter : mappedParametersConAnno) {
            fieldNameConstructorParameters.put(constructorParameter.fieldName, constructorParameter);
        }
        return fieldNameConstructorParameters;
    }

    private static String createConstructorParameterString(Class<?>[] parameterTypes, Map<Integer, String> paramIndexFieldName) {
        StringBuilder stringBuilder = new StringBuilder();
        if (parameterTypes == null || parameterTypes.length == 0) {
            return stringBuilder.toString();
        }
        int i = 1;
        for (Class<?> parameterType : parameterTypes) {
            stringBuilder.append(parameterType.getSimpleName()).append(" ");
            if (paramIndexFieldName == null || !paramIndexFieldName.containsKey(i)) {
                stringBuilder.append("param").append(i);
            } else {
                stringBuilder.append(paramIndexFieldName.get(i - 1));
            }
            stringBuilder.append(", ");
            i++;
        }
        return stringBuilder.substring(0, stringBuilder.length() - 2);
    }

    private static boolean isNoArgConstructor(Constructor<?> constructor) {
        return constructor.getParameterTypes().length == 0;
    }

    private static class TypeAndFields {
        private final Class<?> type;
        private final List<Field> fields;

        private TypeAndFields(Class<?> type, List<Field> fields) {
            this.type = type;
            this.fields = fields;
        }
    }

    public static class ConstructorMatch<T> {
        private final Constructor<T> constructor;
        private final List<PropertyDescription<T, ?>> constructorParameters;
        private final Map<String, PropertyDescription<T, ?>> setterProperties;
        private final List<String> notMatchingConstructors;

        public ConstructorMatch(Constructor<T> constructor, List<PropertyDescription<T, ?>> constructorParameters, Map<String, PropertyDescription<T, ?>> propertiesToUseSetter, List<String> notMatchingConstructors) {
            this.constructor = constructor;
            this.constructorParameters = constructorParameters;
            this.setterProperties = propertiesToUseSetter;
            this.notMatchingConstructors = notMatchingConstructors;
        }

        public ConstructorMatch(List<String> notMatchingConstructors) {
            this(null, Collections.emptyList(), Collections.emptyMap(), notMatchingConstructors);
        }

        public Constructor<T> getConstructor() {
            return constructor;
        }

        public List<PropertyDescription<T, ?>> getConstructorParameters() {
            return constructorParameters;
        }

        public Map<String, PropertyDescription<T, ?>> getSetterProperties() {
            return setterProperties;
        }

        public boolean isConstructorFound() {
            return constructor != null;
        }

        public List<String> getNotMatchingConstructors() {
            return notMatchingConstructors;
        }
    }

    private static class ConstructorParameter {
        private final int parameterIndex;
        private final String fieldName;

        private ConstructorParameter(int parameterIndex, String fieldName) {
            this.parameterIndex = parameterIndex;
            this.fieldName = fieldName;
        }
    }

    private static class ConstructionSetter {
        private final String fieldName;
        private final Method setterMethod;

        private ConstructionSetter(String fieldName, Method setterMethod) {
            this.fieldName = fieldName;
            this.setterMethod = setterMethod;
        }
    }
}
