package com.bitcrunzh.generic.config.reflection;

import com.bitcrunzh.generic.config.description.java.ClassDescriptionCache;
import com.bitcrunzh.generic.config.description.java.PropertyDescription;
import com.bitcrunzh.generic.config.reflection.annotation.util.ConstructParamFieldMapping;
import com.bitcrunzh.generic.config.reflection.annotation.util.FieldGetter;
import com.bitcrunzh.generic.config.reflection.annotation.util.FieldSetter;
import com.bitcrunzh.generic.config.value.java.NormalizedObject;
import com.bitcrunzh.generic.config.value.java.NormalizedProperty;

import java.lang.reflect.*;
import java.util.*;
import java.util.function.Function;

public class ReflectionUtil {

    private ReflectionUtil() {
    }

    public static boolean isAbstractClassOrInterface(Class<?> type) {
        return Modifier.isInterface(type.getModifiers()) || Modifier.isAbstract(type.getModifiers());
    }

    public static <T> Method findSetterMethod(Class<T> parentType, Field fieldToFindSetterFor) {
        String nameToMatch = String.format("set%s", fieldToFindSetterFor.getName());
        for (Method method : parentType.getMethods()) {
            Method matchingMethod = null;
            if (method.getName().equalsIgnoreCase(nameToMatch)) {
                matchingMethod = method;
            }
            FieldSetter setterAnnotation = method.getAnnotation(FieldSetter.class);
            if (matchingMethod == null && setterAnnotation != null && setterAnnotation.fieldName().equals(fieldToFindSetterFor.getName())) {
                matchingMethod = method;
            }
            Class<?>[] setterParameters = method.getParameterTypes();
            if (!isUsableSetterMethod(fieldToFindSetterFor, method, setterParameters)) continue;
            if (matchingMethod != null) {
                return matchingMethod;
            }
        }
        return null;
    }

    private static boolean isUsableSetterMethod(Field fieldToFindSetterFor, Method method, Class<?>[] setterParameters) {
        if (setterParameters.length != 1 || !setterParameters[0].isAssignableFrom(fieldToFindSetterFor.getType())) {
            return false; //Setter method should only take the value to set.
        }
        //Setter should be public for the framework to use it. Compiler bridge methods should not be used as they will have the wrong type to set even though name matches.
        return Modifier.isPublic(method.getModifiers()) && !method.isBridge();
    }

    public static <T> Method findGetterMethod(Class<T> parentType, Field fieldToFindGetterFor) {
        List<String> namesToTryMatch = new ArrayList<>();
        if (fieldToFindGetterFor.getType() == Boolean.class || fieldToFindGetterFor.getType() == boolean.class) {
            if (fieldToFindGetterFor.getName().startsWith("is")) {
                namesToTryMatch.add(fieldToFindGetterFor.getName());
            }
            namesToTryMatch.add(String.format("is%s", fieldToFindGetterFor.getName()));
        }
        namesToTryMatch.add(String.format("get%s", fieldToFindGetterFor.getName()));

        for (Method method : parentType.getMethods()) {
            Method methodFound = findGetterMethodFromGetterAnnotation(parentType, fieldToFindGetterFor, method);
            if (methodFound == null) {
                methodFound = findGetterMethodFromFieldName(fieldToFindGetterFor, method, namesToTryMatch);
            }
            if (methodFound != null) return methodFound;
        }
        throw new IllegalArgumentException(String.format("Unable to find getter method for '%s.%s:%s'", parentType.getSimpleName(), fieldToFindGetterFor.getName(), fieldToFindGetterFor.getType().getSimpleName()));
    }

    private static Method findGetterMethodFromFieldName(Field fieldToFindGetterFor, Method method, List<String> namesToTryMatch) {
        for (String nameToMatch : namesToTryMatch) {
            if (!Modifier.isPublic(method.getModifiers()) || method.isBridge()) {
                continue;
            }
            if (method.getName().equalsIgnoreCase(nameToMatch) && (method.getReturnType().isPrimitive() || fieldToFindGetterFor.getType().isAssignableFrom(method.getReturnType()))) {
                return method;
            }
        }
        return null;
    }

    private static <T> Method findGetterMethodFromGetterAnnotation(Class<T> parentType, Field fieldToFindGetterFor, Method method) {
        FieldGetter getterAnnotation = method.getAnnotation(FieldGetter.class);
        if (getterAnnotation != null && getterAnnotation.fieldName().equals(fieldToFindGetterFor.getName())) {
            if (method.isBridge()) { //Method generated by the Java Compiler, using Object for generic types, including those declared in interfaces, even though implemented as specific type in a class.
                return null;
            }
            if (method.getReturnType().isPrimitive() || fieldToFindGetterFor.getType().isAssignableFrom(method.getReturnType())) {
                return method;
            } else {
                throw new IllegalArgumentException(String.format("Method '%s.%s:%s', is annotated as a getter for field '%s:%s' but types does not match.", parentType.getSimpleName(), method.getName(), method.getReturnType().getSimpleName(), fieldToFindGetterFor.getName(), fieldToFindGetterFor.getType().getSimpleName()));
            }
        }
        return null;
    }

    public static <T> Function<NormalizedObject<T>, T> findconstructor(List<PropertyDescription<T, ?>> propertyDescriptions, Class<T> type) {
        return new ConstructorMatch<>(true, );
    }

    private static <T> Function<NormalizedObject<T>, T> createConstructor(final Class<T> type, List<PropertyDescription<T, ?>> propertyDescriptions) {
        Map<String, PropertyDescription<T, ?>> propertyMap = new HashMap<>();
        List<PropertyDescription<T, ?>> propertyDescriptionsToMatch = new ArrayList<>(propertyDescriptions);
        for (PropertyDescription<T, ?> property : propertyDescriptionsToMatch) {
            propertyMap.put(property.getPropertyName(), property);
        }

        List<String> notMatchingConstructors = new ArrayList<>();
        for (final Constructor<?> constructor : type.getDeclaredConstructors()) {
            @SuppressWarnings("unchecked") ConstructorMatch<T> typedConstructor = createConstructorFunctionIfMatchesProperties(type, propertyDescriptionsToMatch, (Constructor<T>) constructor, notMatchingConstructors, propertyMap);
            if (typedConstructor != null) return typedConstructor;
        }
        StringBuilder stringBuilder = new StringBuilder();
        int i = 1;
        for (String notMatchingConstructor : notMatchingConstructors) {
            stringBuilder.append(System.lineSeparator()).append(i++).append(") ").append(notMatchingConstructor);
        }
        throw new IllegalStateException(String.format("No suitable public constructor found for type %s. The following constructors was found but not matching:%s", type.getSimpleName(), stringBuilder));
    }

    private static <T> Function<NormalizedObject<T>, T> createConstructorFunctionIfMatchesProperties(Class<T> type, List<PropertyDescription<T, ?>> propertyDescriptions, Constructor<T> constructor, List<String> notMatchingConstructors, Map<String, PropertyDescription<T, ?>> propertyMap) {
        if (!type.isAssignableFrom(constructor.getDeclaringClass())) {
            return null;
        }
        if (!Modifier.isPublic(constructor.getModifiers())) {
            notMatchingConstructors.add(String.format("%s(%s) - Not public access modifier.", type.getSimpleName(), createConstructorParameterString(constructor.getParameterTypes(), null)));
            return null;
        }
        final Constructor<T> typedConstructor = constructor;

        Set<String> unassignedParameters = new HashSet<>();
        for (PropertyDescription<T, ?> propertyDescription : propertyDescriptions) {
            unassignedParameters.add(propertyDescription.getPropertyName());
        }

        if (propertyDescriptions.isEmpty()) {
            if (isNoArgConstructor(typedConstructor)) {
                return createEmptyConstructorFunction(typedConstructor);
            } else {
                notMatchingConstructors.add(String.format("%s(%s) - Constructor has parameters, but there is no annotated properties to set.", type.getSimpleName(), createConstructorParameterString(constructor.getParameterTypes(), null)));
                return null;
            }
        }

        Class<?>[] parameterTypes = typedConstructor.getParameterTypes();
        List<ConstructorParameter> mappedParametersConAnno = mapConstructorParametersToFields(type, typedConstructor.getAnnotation(ConstructParamFieldMapping.class), parameterTypes, propertyMap);

        final Map<String, ConstructorParameter> fieldNameConstructorParameters = createFieldNameToConstructorParameterMap(mappedParametersConAnno);
        if (parameterTypes.length > 0 && fieldNameConstructorParameters.size() != parameterTypes.length) {
            notMatchingConstructors.add(String.format("%s(%s) - Constructor has parameters, but they are not all mapped to fields. Please use either @%s or @%s constructor annotations to map constructor parameters to field names.", type.getSimpleName(), createConstructorParameterString(constructor.getParameterTypes(), null), ParameterFieldMappings.class.getSimpleName(), ParameterFieldMapping.class.getSimpleName()));
            return null;
        }

        final Map<Integer, String> constructorParamIndexFieldName = createConstructorParameterIndexAndUpdateUnassignedParameters(fieldNameConstructorParameters, unassignedParameters);
        final List<ConstructionSetter> propertySetters = getConstructionSettersAndUpdateUnassignedParameters(type, unassignedParameters);

        if (!unassignedParameters.isEmpty()) {
            notMatchingConstructors.add(String.format("%s(%s)%s - No setter methods found for fields: %s.", typedConstructor.getDeclaringClass().getSimpleName(), createConstructorParameterString(typedConstructor.getParameterTypes(), constructorParamIndexFieldName), createSetterFoundString(propertySetters), createSetterString(unassignedParameters)));
            return null;
        }

        return normalizedObject -> {
            Object[] constructorParameters = new Object[constructorParamIndexFieldName.size()];
            for (int parameterIndex = 0; parameterIndex < constructorParameters.length; parameterIndex++) {
                String fieldName = constructorParamIndexFieldName.get(parameterIndex);
                constructorParameters[parameterIndex] = normalizedObject.getProperty(fieldName);
            }
            T object = typedConstructor.newInstance(constructorParameters);
            for (ConstructionSetter propertySetter : propertySetters) {
                Object value = normalizedObject.getValue(propertySetter.fieldName);
                propertySetter.setterMethod.invoke(object, value);
            }
            return object;
        };
    }

    private static <T> Function<NormalizedObject<T>, T> createEmptyConstructorFunction(Constructor<T> typedConstructor) {
        return normalizedObject -> {
            try {
                return typedConstructor.newInstance();
            } catch (InstantiationException e) {
                throw new IllegalStateException("Failed to instantiate object.", e);
            } catch (IllegalAccessException e) {
                throw new IllegalStateException("Failed to instantiate object. Constructor must be public.", e);
            } catch (InvocationTargetException e) {
                throw new IllegalStateException("Failed to instantiate object. Wrong invocation target.", e);
            }
        };
    }

    private static <T> List<ConstructorParameter> mapConstructorParametersToFields(Class<T> type, ConstructParamFieldMapping parameterFieldMappings, Class<?>[] parameterTypes, Map<String, PropertyDescription<T, ?>> propertyMap) {
        if (parameterFieldMappings == null) {
            return Collections.emptyList();
        }
        if (parameterFieldMappings.fieldNames().length != parameterTypes.length) {
            throw new IllegalArgumentException(String.format("@ConstructorParameterFields annotation for type '%s' must have the same number of fieldNames as there is constructor parameter arguments. Was '%d' (%s), expected '%d'.", type.getSimpleName(), parameterFieldMappings.fieldNames().length, Arrays.asList(parameterFieldMappings.fieldNames()), parameterTypes.length));
        }
        List<ConstructorParameter> mappedConstructorParameters = new ArrayList<>();
        for (int idx = 0; idx < parameterFieldMappings.fieldNames().length; idx++) {
            Class<?> parameterType = parameterTypes[idx];
            String fieldName = parameterFieldMappings.fieldNames()[idx];
            assertConstructorParameterFieldMappingValid(type, propertyMap, ParameterFieldMappings.class, fieldName, parameterType);
            mappedConstructorParameters.add(new ConstructorParameter(idx, fieldName));
        }
        return mappedConstructorParameters;
    }

    private static Map<String, ConstructorParameter> createFieldNameToConstructorParameterMap(List<ConstructorParameter> mappedParametersConAnno) {
        Map<String, ConstructorParameter> fieldNameConstructorParameters = new HashMap<>();
        for (ConstructorParameter constructorParameter : mappedParametersConAnno) {
            fieldNameConstructorParameters.put(constructorParameter.fieldName, constructorParameter);
        }
        return fieldNameConstructorParameters;
    }

    private static String createConstructorParameterString(Class<?>[] parameterTypes, Map<Integer, String> paramIndexFieldName) {
        StringBuilder stringBuilder = new StringBuilder();
        if (parameterTypes == null || parameterTypes.length == 0) {
            return stringBuilder.toString();
        }
        int i = 1;
        for (Class<?> parameterType : parameterTypes) {
            stringBuilder.append(parameterType.getSimpleName()).append(" ");
            if (paramIndexFieldName == null || !paramIndexFieldName.containsKey(i)) {
                stringBuilder.append("param").append(i);
            } else {
                stringBuilder.append(paramIndexFieldName.get(i - 1));
            }
            stringBuilder.append(", ");
            i++;
        }
        return stringBuilder.substring(0, stringBuilder.length() - 2);
    }

    private static boolean isNoArgConstructor(Constructor<?> constructor) {
        return constructor.getParameterTypes().length == 0;
    }
    private static <T> Function<NormalizedObject<T>, T> createConstructorFunctionFromMatch(ReflectionUtil.ConstructorMatch<T> constructorMatch, List<PropertyDescription<T, ?>> propertyDescriptions, Class<T> type, ClassDescriptionCache classDescriptionCache) {
        Map<String, PropertyDescription<T, ?>> propertyDescriptionMap = new HashMap<>();
        for (PropertyDescription<T, ?> propertyDescription : propertyDescriptions) {
            propertyDescriptionMap.put(propertyDescription.getPropertyName(), propertyDescription);
        }
        return normalizedObject -> {
            Object[] constructorArgs = getConstructorArgs(normalizedObject, constructorMatch, classDescriptionCache);
            try {
                T object = constructorMatch.getConstructor().newInstance(constructorArgs);
                for (PropertyDescription<T, ?> propertyDescription : constructorMatch.getSetterProperties().values()) {
                    NormalizedProperty<?> normalizedPropertyValue = normalizedObject.getProperty(propertyDescription.getPropertyName());
                    //noinspection unchecked,CastCanBeRemovedNarrowingVariableType
                    setProperty(object, (NormalizedProperty<Object>) normalizedPropertyValue, (PropertyDescription<T, Object>) propertyDescription, classDescriptionCache);
                }
                return object;
            } catch (InstantiationException e) {
                throw new IllegalStateException("Failed to instantiate object.", e);
            } catch (IllegalAccessException e) {
                throw new IllegalStateException("Failed to instantiate object. Constructor must be public.", e);
            } catch (InvocationTargetException e) {
                throw new IllegalStateException("Failed to instantiate object. Wrong invocation target.", e);
            }
        };
    }

    private static <T, V> Object[] getConstructorArgs(NormalizedObject<T> normalizedObject, ReflectionUtil.ConstructorMatch<T> constructorMatch, ClassDescriptionCache classDescriptionCache) {
        Object[] constructorParameters = new Object[constructorMatch.getConstructorParameters().size()];
        for (int i = 0; i < constructorMatch.getConstructorParameters().size(); i++) {
            @SuppressWarnings("unchecked") PropertyDescription<T, V> propertyDescription = (PropertyDescription<T, V>) constructorMatch.getConstructorParameters().get(i);
            NormalizedProperty<V> normalizedProperty = normalizedObject.getProperty(propertyDescription.getPropertyName());
            V property = getProperty(normalizedProperty, propertyDescription, classDescriptionCache);
            constructorParameters[i] = property;
        }
        return constructorParameters;
    }

    private static <T, V> V getProperty(NormalizedProperty<V> normalizedPropertyValue, PropertyDescription<T, V> propertyDescription, ClassDescriptionCache classDescriptionCache) {
        return propertyDescription.createProperty(normalizedPropertyValue, classDescriptionCache).orElse(null);
    }

    private static <T, V> void setProperty(T object, NormalizedProperty<V> normalizedPropertyValue, PropertyDescription<T, V> propertyDescription, ClassDescriptionCache classDescriptionCache) {
        V value = getProperty(normalizedPropertyValue, propertyDescription, classDescriptionCache);
        propertyDescription.getSetterFunction().orElseThrow(() -> new IllegalStateException("No setter function for property " + normalizedPropertyValue.getPropertyName())).accept(object, value);
    }


    public static class ConstructorMatch<T> {
        private final Constructor<T> constructor;
        private final List<PropertyDescription<T, ?>> constructorParameters;
        private final Map<String, PropertyDescription<T, ?>> setterProperties;
        private final List<String> notMatchingConstructors;

        public ConstructorMatch(Constructor<T> constructor, List<PropertyDescription<T, ?>> constructorParameters, Map<String, PropertyDescription<T, ?>> propertiesToUseSetter, List<String> notMatchingConstructors) {
            this.constructor = constructor;
            this.constructorParameters = constructorParameters;
            this.setterProperties = propertiesToUseSetter;
            this.notMatchingConstructors = notMatchingConstructors;
        }

        public ConstructorMatch(List<String> notMatchingConstructors) {
            this(null, Collections.emptyList(), Collections.emptyMap(), notMatchingConstructors);
        }

        public Constructor<T> getConstructor() {
            return constructor;
        }

        public List<PropertyDescription<T, ?>> getConstructorParameters() {
            return constructorParameters;
        }

        public Map<String, PropertyDescription<T, ?>> getSetterProperties() {
            return setterProperties;
        }

        public boolean isConstructorFound() {
            return constructor != null;
        }

        public List<String> getNotMatchingConstructors() {
            return notMatchingConstructors;
        }
    }

    private static class ConstructorParameter {
        private final int parameterIndex;
        private final String fieldName;

        private ConstructorParameter(int parameterIndex, String fieldName) {
            this.parameterIndex = parameterIndex;
            this.fieldName = fieldName;
        }
    }

    private static class ConstructionSetter {
        private final String fieldName;
        private final Method setterMethod;

        private ConstructionSetter(String fieldName, Method setterMethod) {
            this.fieldName = fieldName;
            this.setterMethod = setterMethod;
        }
    }
}
